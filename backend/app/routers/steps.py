"""
Step API Router (Phase 12.3).

Provides endpoints for control layer communication:
- POST /api/steps/{step_id}/status - Report status changes
- POST /api/steps/{step_id}/logs - Stream log lines
- POST /api/steps/{step_id}/heartbeat - Send heartbeat

These endpoints are called by the control layer running inside step containers.
Authentication is via Bearer token generated by LocalExecutor before container start.
"""
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.database import get_db
from app.schemas.steps import (
    StatusUpdate,
    LogsUpdate,
    HeartbeatRequest,
    StatusResponse,
    LogsResponse,
    HeartbeatResponse,
    StepStatus,
)
from app.services.execution.step_token import (
    verify_step_token,
)
from app.services.websocket import manager


router = APIRouter(prefix="/api/steps", tags=["steps"])


# In-memory storage for step state
# In production, this would be in the database
# For now, we store logs and status per step_id
_step_logs: dict[str, list[str]] = {}
_step_status: dict[str, dict] = {}


def _get_step_logs(step_id: str) -> list[str]:
    """Get or create logs list for a step."""
    if step_id not in _step_logs:
        _step_logs[step_id] = []
    return _step_logs[step_id]


def _get_step_status(step_id: str) -> dict:
    """Get or create status dict for a step."""
    if step_id not in _step_status:
        _step_status[step_id] = {
            "status": "pending",
            "exit_code": None,
            "error": None,
            "last_heartbeat": None,
        }
    return _step_status[step_id]


# -----------------------------------------------------------------------------
# Status Endpoint
# -----------------------------------------------------------------------------

@router.post("/{step_id}/status", response_model=StatusResponse)
async def update_status(
    step_id: str,
    request: StatusUpdate,
    db: AsyncSession = Depends(get_db),
    token_data: dict = Depends(verify_step_token),
):
    """
    Update step execution status.

    Called by control layer when:
    - Step starts running (status=running)
    - Step completes successfully (status=completed, exit_code=0)
    - Step fails (status=failed, exit_code!=0, optional error)

    Requires Bearer token matching the step_id.
    """
    # Verify token matches step_id
    if token_data["step_id"] != step_id:
        raise HTTPException(
            status_code=403,
            detail="Token does not match step_id",
        )

    # Update in-memory status
    status = _get_step_status(step_id)
    status["status"] = request.status.value
    status["exit_code"] = request.exit_code
    status["error"] = request.error
    status["updated_at"] = datetime.utcnow().isoformat()

    # Broadcast status update via WebSocket
    await manager.broadcast("step_status", {
        "step_id": step_id,
        "status": request.status.value,
        "exit_code": request.exit_code,
        "error": request.error,
    })

    return StatusResponse(status="ok")


# -----------------------------------------------------------------------------
# Logs Endpoint
# -----------------------------------------------------------------------------

@router.post("/{step_id}/logs", response_model=LogsResponse)
async def append_logs(
    step_id: str,
    request: LogsUpdate,
    db: AsyncSession = Depends(get_db),
    token_data: dict = Depends(verify_step_token),
):
    """
    Append log lines to step execution.

    Called by control layer periodically during execution.
    Lines are batched for efficiency (typically 100 lines or 1 second).

    Requires Bearer token matching the step_id.
    """
    # Verify token matches step_id
    if token_data["step_id"] != step_id:
        raise HTTPException(
            status_code=403,
            detail="Token does not match step_id",
        )

    # Append to in-memory logs
    logs = _get_step_logs(step_id)
    logs.extend(request.lines)

    # Broadcast log update via WebSocket
    if request.lines:
        await manager.broadcast("step_logs", {
            "step_id": step_id,
            "lines": request.lines,
        })

    return LogsResponse(status="ok", total_lines=len(logs))


# -----------------------------------------------------------------------------
# Heartbeat Endpoint
# -----------------------------------------------------------------------------

@router.post("/{step_id}/heartbeat", response_model=HeartbeatResponse)
async def heartbeat(
    step_id: str,
    request: HeartbeatRequest,
    db: AsyncSession = Depends(get_db),
    token_data: dict = Depends(verify_step_token),
):
    """
    Receive heartbeat from running step.

    Called by control layer every 10 seconds to prove liveness.
    Backend can use heartbeat timeout to detect dead steps.

    Requires Bearer token matching the step_id.
    """
    # Verify token matches step_id
    if token_data["step_id"] != step_id:
        raise HTTPException(
            status_code=403,
            detail="Token does not match step_id",
        )

    # Update heartbeat timestamp
    status = _get_step_status(step_id)
    status["last_heartbeat"] = datetime.utcnow().isoformat()

    return HeartbeatResponse(status="ok")


# -----------------------------------------------------------------------------
# Helper Functions for Testing/Debugging
# -----------------------------------------------------------------------------

def get_step_logs(step_id: str) -> list[str]:
    """Get logs for a step. For testing/debugging."""
    return _step_logs.get(step_id, [])


def get_step_status(step_id: str) -> Optional[dict]:
    """Get status for a step. For testing/debugging."""
    return _step_status.get(step_id)


def clear_step_data(step_id: str) -> None:
    """Clear all data for a step. For testing."""
    _step_logs.pop(step_id, None)
    _step_status.pop(step_id, None)


def clear_all_step_data() -> None:
    """Clear all step data. For testing."""
    _step_logs.clear()
    _step_status.clear()
